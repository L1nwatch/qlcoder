#!/bin/env python3
# -*- coding: utf-8 -*-
# version: Python3.X
"""
2017.02.16 题 13
    1. 产生随机列表
    2. 读入矩阵并输出对角线之和
    3. 实现矩阵转置
"""
import random
import copy

__author__ = '__L1n__w@tch'


class Solve:
    @staticmethod
    def create_random_list():
        """
        调用随机函数产生一个列表, 要求不能每次产生的列表中的元素都一样
        即第一次调用的结果 [1, 2 ,3], 第二次调用的结果不能是 [1, 2, 3], 如果是 [3, 2, 1] 等就算可以
        参考资料: random 库的使用
        :return: list(), 只要是列表即可, 不要求有几个元素, 但要求多次调用产生的列表不同
        """
        pass

    @staticmethod
    def sum_matrix_cross(n):
        """
        从标准输入流中读取一个 3 行, 3 列的矩阵的各个元素, 然后输出主对角线元素之和
        demo input
            1
            2
            3
            4
            5
            6
            7
            8
            9
        demo output
            1 + 5 + 9
        参考思路:
            1. 通过两个 for 循环实现从标准输入流读取与创建矩阵
            2. 拿到矩阵之后观察主对角线下标的规律, 遍历每个元素符合该规律的就进行求和操作
        :param n: int(), 表示矩阵的行列数, 这里行数和列数相等, 范围为 1 <= n <= 10
        :return: int(), 计算得到矩阵主对角线元素之和, 比如 demo 的答案就是 15
        """
        pass

    @staticmethod
    def transpose_matrix(matrix):
        """
        实现矩阵的转置, 即行列互换
        比如
            100 200 300
            400 500 600
            700 800 900
        应该输出
            100 400 700
            200 500 800
            300 600 900
        参考思路:
            1. 实现矩阵的复制, 可以参考 题目9-multi_half_matrix 中的复制方法
            2. 观察下标规律, 比如说 [0][0] 的元素依旧应该放在 [0][0] 中, [0][1] 的元素得放在 [1][0] 中
            3. 通过下标遍历矩阵的每个元素, 根据下标规律重新给新矩阵进行赋值操作
            4. 返回新矩阵
        :param matrix: list(), 多维矩阵, 维数为 1 <= 维数 <= 10, 比如 [[100, 200, 300], [400, 500, 600], [700, 800, 900]]
        :return: list(), 转置后的矩阵, 比如 [[100, 400, 700], [200, 500, 800], [300, 600, 900]]
        """
        pass


if __name__ == "__main__":
    pass
